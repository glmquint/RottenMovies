%\include{./preamble}
%\begin{document}
\chapter{Graph database}
\justifying
\section{Structure of the graph}
The DBSM chosen for the graph database is Neo4j, it is used to manege the social part of the site and also to keep track of the reviews made for the feed and suggestion functionality.


The entities used in the database are:
\begin{itemize}
	\item User
	\item TopCritic
	\item Movie
\end{itemize}
The nodes themselves do not store a lot of data, we decided to keep the bare minimum by having the following attributes:
\begin{itemize}
	\item for the User and TopCritic:
	\begin{itemize}
		\item id
		\item name
	\end{itemize}
	\item for Movie:
	\begin{itemize}
		\item id
		\item title
	\end{itemize}
\end{itemize}
The existing relationships are:
\begin{itemize}
	\item User -[:FOLLOWS]-> TopCritic
	\item User -[:REVIEWED]-> Movie
	\item TopCritic -[:REVIEWED]-> Movie
\end{itemize}
In particular the \emph{REVIEWED} relationship contains the following information:
\begin{itemize}
	\item content excerpt 
	\item date
	\item freshness: 
\end{itemize}

Below is shown a snapshot of the graph database taken from Neo4j.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.45]{/images/PNG/graph.png}
\caption{graph DB}
\label{fig:graphDB}
\end{center}
\end{figure}

As previously stated in the Feasibility study section \ref{sec:result}, the graph database design was heavily influenced by the document one, it was in fact generated by a Python script \cref{subsec:createGraphDB} that starts from the movie collection and, after generating the nodes for the \emph{Movie} entity, does the same for the user by distinguishing them between normal users and top critics. It then generates the \emph{REVIEWED} relationship based upon the data stored in the document database and finally it generates the \emph{FOLLOWS} relationship randomly, the total storage size of the database is 89 MB.

\section{Index}
The \emph{id} attributes are common to all nodes and they store a string which is also used as id by the document database in the \emph{\textunderscore id} field. This choice was made so that we could have a way to identify the same object across the different databases with only one string from the application. Due to the OOP language used in the application the data was manipulated with classes containing the id of the object so, to improve the performance of the graph database we decided to use the \emph{id} attribute as an index. 

Below is the information in a json format from the Neo4j DBMS about the new index (some attributes were omitted for space)
\lstinputlisting[language=json, caption = Neo4jID]{./../code/graphIndex.json}

We then proceed to profile the queries with and without the above indexes, here we can see the result of this analysis: 
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.33]{/images/neo4j_stats/find_movie_by_id.png}
\caption{search by id without and with movie\textunderscore id \textunderscore index}
\label{fig:movieId}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.33]{/images/neo4j_stats/find_user_by_id.png}
\caption{search by id without and with user\textunderscore id \textunderscore index}
\label{fig:userId}
\end{center}
\end{figure}


\section{Queries}
In the following section we will show the queries that drove the design of the graph database.
\begin{center}
\begin{tabular}{|p{8cm} ||p{8cm}|}
\hline
Graph-Centric Query & Domain-Specific Query \\
\hline\hline
Which are the User nodes with the most outgoing edges of type REVIEWED & Which are the non top critic users with most reviews made\\
\hline
Which are the TopCritic nodes with the most incoming edges of type FOLLOWS & Which are the most followed top critics \\
\hline
Which are the Movies nodes that have been most recently connected with TopCritic nodes by a REVIEWED relationship meanwhile the latter are connected to a User node with a FOLLOWS relationship & Which are the latest reviewed movies by followed top critics given a starting user \\
\hline
Which are the User and TopCritic nodes that have outgoing REVIEWED edges to the same Movie node without having a FOLLOWS edge between them, which of these TopCritic nodes have more similar attribute on the REVIEWED relationship with the one on the same type going towards the same Movie node given a User node & Which are the non-followed top critics with the most affinity towards a given user\\
\hline
Check if a Movie node has different ratio of freshness in the incoming REVIEWED edges split based on their date attribute & Check if a movie has been targeted by review bombing in the last x months\\
\hline

\end{tabular}
\end{center}

In the following pages are presented the implementation in Java of the queries
\subsection{Users with most reviews}
\begin{lstlisting}[language = Java, caption = mostActiveUser]
ArrayList<UserLeaderboardDTO> userList = session.readTransaction((TransactionWork<ArrayList<UserLeaderboardDTO>>) tx ->{
            String query = "MATCH (b)-[:REVIEWED]->(m:Movie) " +
                    "RETURN b.id as Id, b.name AS Name, count(*) as NumMovies, labels(b) as Type " +
                    "ORDER BY NumMovies DESC " +
                    "LIMIT 10";
            Result result = tx.run(query);
            ArrayList<UserLeaderboardDTO> list = new ArrayList<>();
            while(result.hasNext()){
                Record r = result.next();
                UserLeaderboardDTO user = new UserLeaderboardDTO();
                user.setId(new ObjectId(r.get("Id").asString()));
                user.setUsername(r.get("Name").asString());
                user.setCounter(r.get("NumMovies").asInt());
                user.setType(r.get("Type").get(0).asString());
                list.add(user);
            }
            return list;
        });
\end{lstlisting}

\subsection{Most followed top critics}
\begin{lstlisting}[language = Java, caption = mostFollowTopCritic]
ArrayList<UserLeaderboardDTO> userList = session.readTransaction((TransactionWork<ArrayList<UserLeaderboardDTO>>) tx ->{
            String query = "MATCH (t:TopCritic)<-[:FOLLOWS]-(u:User) " +
                    "RETURN t.id as Id, t.name AS Name, count(*) as NumMovies " +
                    "ORDER BY NumMovies DESC " +
                    "LIMIT 10";
            Result result = tx.run(query);
            ArrayList<UserLeaderboardDTO> list = new ArrayList<>();
            while(result.hasNext()){
                Record r = result.next();
                UserLeaderboardDTO user = new UserLeaderboardDTO();
                user.setId(new ObjectId(r.get("Id").asString()));
                user.setUsername(r.get("Name").asString());
                user.setCounter(r.get("NumMovies").asInt());
                list.add(user);
            }
            return list;


        });
\end{lstlisting}


\subsection{Latest review movies by followed top critics}
\begin{lstlisting}[language = Java, caption = Latest reviews]
ArrayList<ReviewFeedDTO> reviewFeed = session.readTransaction((TransactionWork<ArrayList<ReviewFeedDTO>>)(tx -> {
            String query = "MATCH(u:User{id:$userId})-[f:FOLLOWS]->(t:TopCritic)-[r:REVIEWED]->(m:Movie) "+
                    "RETURN t.id as Id, m.title AS movieTitle, m.id AS movieId, t.name AS criticName, r.date AS reviewDate, "+
                    "r.content AS content, r.freshness AS freshness " +
                    "ORDER BY r.date DESC SKIP $skip LIMIT $limit ";
            Result result = tx.run(query, parameters("userId", usr.getId().toString(),
                    "skip", skip, "limit", REVIEWS_IN_FEED));
            ArrayList<ReviewFeedDTO> feed = new ArrayList<>();
            while(result.hasNext()){
                Record r = result.next();
                Date date;
                try {
                    date = new SimpleDateFormat("yyyy-MM-dd").parse(String.valueOf(r.get("reviewDate").asLocalDate()));
                } catch (ParseException e) {
                    throw new RuntimeException(e);
                }
                feed.add(new ReviewFeedDTO(
                        r.get("Id").asString(),
                        r.get("movieTitle").asString(),
                        r.get("movieId").asString(),
                        r.get("criticName").asString(),
                        r.get("content").asString(),
                        r.get("freshness").asBoolean(),
                        date
                ));
            }
            return feed;
        }));
\end{lstlisting}

\subsection{Non-followed top critics with the most affinity}
\begin{lstlisting}[language = Java, caption = suggestion feed]
ArrayList<TopCriticSuggestionDTO> suggestionFeed = session.readTransaction((TransactionWork<ArrayList<TopCriticSuggestionDTO>>)(tx -> {
            String query = "MATCH(u:User{id:$userId})-[r:REVIEWED]->(m:Movie)<-[r2:REVIEWED]-(t:TopCritic) "+
                    "WHERE NOT (u)-[:FOLLOWS]->(t) " +
                    "RETURN 100*(toFloat(sum(case when r.freshness = r2.freshness then 1 else 0 end)+1)/(count(m.title)+2)) as Rate, "+
                    "t.name as Name, t.id as Id ORDER BY Rate DESC SKIP $skip LIMIT $limit";
            Result result = tx.run(query, parameters("userId", usr.getId().toString(),
                    "skip", skip, "limit", SUGGESTIONS_IN_FEED));
            ArrayList<TopCriticSuggestionDTO> feed = new ArrayList<>();
            while(result.hasNext()){
                Record r = result.next();

                feed.add(new TopCriticSuggestionDTO(
                        r.get("Id").asString(),
                        r.get("Name").asString(),
                        (int) r.get("Rate").asDouble()
                ));
            }
            return feed;
        }));
\end{lstlisting}

\subsection{Check for review bombing}
\begin{lstlisting}[language = Java, caption = review bombing]
reviewBombingList = session.readTransaction((TransactionWork<MovieReviewBombingDTO>)(tx -> {
            String query = "MATCH (m:Movie{id:$movieId})<-[r:REVIEWED]-() " +
                    "WITH SUM(CASE WHEN r.date<date(\""+strDate+"\") THEN 1 ELSE 0 END) as StoricCount, " +
                    "100*toFloat(SUM(CASE WHEN r.date<date(\""+strDate+"\") AND r.freshness = true THEN 1 ELSE 0 END))" +
                    "/SUM(CASE WHEN r.date<date(\""+strDate+"\") THEN 1 ELSE 0 END) as StoricRate, " +
                    "SUM(CASE WHEN r.date>=date(\""+strDate+"\") AND r.date<date(\""+todayString+"\") THEN 1 ELSE 0 END) as TargetCount, " +
                    "100*toFloat(SUM(CASE WHEN r.date>=date(\""+strDate+"\") AND r.date<date(\""+todayString+"\") AND r.freshness = true THEN 1 ELSE 0 END))" +
                    "/SUM(CASE WHEN r.date>=date(\""+strDate+"\") AND r.date<date(\""+todayString+"\") THEN 1 ELSE 0 END) as TargetRate, m.title as Title " +
                    "RETURN Title, StoricCount, StoricRate, TargetCount, TargetRate";
            Result result=null;
            try{
                result=tx.run(query, parameters("movieId", movie.getId().toString(),
                        "date", strDate));
            }
            catch (org.neo4j.driver.exceptions.ClientException e){
                return null;
            }
            MovieReviewBombingDTO feed = new MovieReviewBombingDTO(
                    result.peek().get("Title").asString(),
                    result.peek().get("StoricCount").asInt(),
                    (int)result.peek().get("StoricRate").asDouble(),
                    result.peek().get("TargetCount").asInt(),
                    (int)result.peek().get("TargetRate").asDouble(),
                    LocalDate.now().minusMonths(month)
            );
            return feed;
        }));
\end{lstlisting}
%\end{document}