%\include{./preamble}
%\begin{document}
\chapter{Document database}
\justifying
In this chapter we will discuss the organization of the document database and how we handled the replicas. We decided to use MongoDB as DBMS for the document database for the purpose of storing the main information for movies, users, reviews and personnel. In MongoDB we created the following two collections: 
\begin{itemize}
	\item movie
	\item user
\end{itemize}
Inside the movie collection are embedded the documents for the reviews and personnel
\section{Collection composition}
\subsection{Movie collection}
The following is the composition of a movie document in the collection.
\lstinputlisting[language=json, caption = Movie document]{./../code/movie.json}

As previously stated the field personnel and review are arrays of embedded documents.

\paragraph{}
\subsection{User collection}
The following is the composition of a user document in the collection.
\lstinputlisting[language=json, caption = User document]{./../code/user.json}


It is important to notice that in this collection we have two fields for the reviews, \emph{last3Reviews} and \emph{reviews} which present different ways of storing data for the same underling entity. As suggested by the name itself \emph{last3Reviews} contains the last three review in the form of an embedded document meanwhile \emph{reviews} contains all the reviews made by a user in the form of document linking towards the movie for which they were written; in particular, the link is formed by the id of the movie, the title and the position in which the review can be found in the array \emph{review} of the movie document. This structure was chosen so that we could avoid a full replica of the reviews in both collections and, at the same time, avoiding to perform join operation for those reviews that are more frequently checked, which are the most recent ones. The idea of creating a separated collection for reviews was immediately discarded because it would have implied a design for the document database that resembles a third normal form.

\section{Indexes}
In order to provide the best execution speed in search queries we use indexes. In particular we focus on the application part that is available also without registering to the site, like Hall of Fame and search movies functionalities. Without indexes we need a collection scan in user and movie collections to find the right document. \\
\subsection{Movie collection}
\begin{itemize}
\item primaryTitle
\item year
\item genres
\item top\textunderscore critic \textunderscore rating
\item user\textunderscore rating
\end{itemize}
\lstinputlisting[language=Javascript, caption = Movie collection indexes]{./../code/executionStats/collStats_indexSizes_movie}
\subsection{User collection}
\begin{itemize}
\item username
\item date\textunderscore of \textunderscore birth
\end{itemize}
\lstinputlisting[language=Javascript, caption = User collection indexes]{./../code/executionStats/collStats_indexSizes_user}

We decided to use these indexes because they provide a jump in term of speed in search queries without occupying much space. We accept the fact that writes are slower because our application is read-intesive. We consider the idea of using an index on personnel.primaryName but the cost in term of space was higher than the potential benefit, so we discarded it.
For a full analytic report for the indexes, see appendix. \cref{mongoindexes}
\section{Partition and replicas}
To ensure high availability we deploy a cluster of replicas (3). We install and configure MongoDB on all machines, with these priorities 
\begin{enumerate}
 \item 172.16.5.26 (primary)
 \item 172.16.5.27 (secondary)
 \item 172.16.5.28 (secondary)
 \end{enumerate} 
We decided to use \textbf{nearest read preference} and \textbf{W2 write preference}. In fact we can tolerate that users see temporarily an old version of data with a 33\% chance. 

\section{Aggregations}
In this section we shall discuss the different aggregations that the application will implement, the values between <<>> represent a value passed by an above level.

\subsection{Return the best years by top critic and user ratings}\label{subsec:bestYear}
\subsubsection{Mongo shell}
\lstinputlisting[language=JavaScript, caption = bestYear.js]{./../code/bestYear.js}
\subsubsection{Java implementation}
\begin{lstlisting}[language=Java, caption = MovieMongoDBDAO.java]
AggregateIterable<Document> aggregateResult = collection.aggregate(
                Arrays.asList(
                        Aggregates.group("$year",
                                avg("top_critic_rating", "$top_critic_rating"),
                                avg("user_rating", "$user_rating"),
                                sum("count",1)),
                        Aggregates.match(gte("count",numberOfMovies)),
                        Aggregates.sort(opt.getBsonAggregationSort()),
                        Aggregates.limit(Constants.HALL_OF_FAME_ELEMENT_NUMBERS)
                )
        );
\end{lstlisting}
\subsection{Return the best genres by top critic and user ratings}\label{subsec:HOFGenres}
\subsubsection{Mongo shell}
\lstinputlisting[language=JavaScript, caption = bestGenres.js]{./../code/HOFGenres.js}
\subsubsection{Java implementation}
\begin{lstlisting}[language=Java, caption= MovieMongoDBDAO.java]
AggregateIterable<Document> aggregateResult = collection.aggregate(
                Arrays.asList(
                        Aggregates.unwind("$genres"),
                        Aggregates.group("$genres",
                                avg("top_critic_rating", "$top_critic_rating"),
                                avg("user_rating", "$user_rating"),
                                sum("count",1)),
                        Aggregates.match(gte("count",numberOfMovies)),
                        Aggregates.sort(opt.getBsonAggregationSort()),
                        Aggregates.limit(Constants.HALL_OF_FAME_ELEMENT_NUMBERS)
                )
        );
\end{lstlisting}

\subsection{Return the best production houses by top critic and user ratings}\label{subsec:productionHouses}
\subsubsection{Mongo shell}
\lstinputlisting[language=JavaScript, caption = bestProductionHouses.js]{./../code/productionHouses.js}

\subsubsection{Java implementation}
\begin{lstlisting}[language=Java, caption = MovieMongoDBDAO.java ]
AggregateIterable<Document> aggregateResult = collection.aggregate(
                Arrays.asList(
                        Aggregates.group("$production_company",
                                avg("top_critic_rating", "$top_critic_rating"),
                                avg("user_rating", "$user_rating"),
                                sum("count",1)),
                        Aggregates.match(gte("count",numberOfMovies)),
                        Aggregates.sort(opt.getBsonAggregationSort()),
                        Aggregates.limit(Constants.HALL_OF_FAME_ELEMENT_NUMBERS)
                )
        );
\end{lstlisting}
\subsection{Given a movie count the review it has received by each month}\label{subsec:reviewByYearMonth}
\subsubsection{Mongo shell}
\lstinputlisting[language=JavaScript, caption = movieCount.js]{./../code/reviewByYearMonth.js}
\subsubsection{Java implementation}
\begin{lstlisting}[language=Java, caption = MovieMongoDBDAO.java]
Document yearDoc = new Document("year",new Document("$year","$review.review_date"));
        Document monthDoc = new Document("month",new Document("$month","$review.review_date"));
        ArrayList<Document> test=new ArrayList<>();
        test.add(yearDoc);
        test.add(monthDoc);
        AggregateIterable<Document> aggregateResult = collection.aggregate(
                Arrays.asList(
                        Aggregates.match(eq("_id",id)),
                        Aggregates.unwind("$review"),
                        Aggregates.group(test,
                                sum("count",1)),
                        Aggregates.sort(Sorts.ascending("_id"))
                )
        );
\end{lstlisting}
\subsection{Given a user count the review he/she has made divided by genres}\label{subsec:preferredGenres}
\subsubsection{Mongo shell}
\lstinputlisting[language=JavaScript, caption = genreCount.js]{./../code/preferredGenres.js}

\subsubsection{Java implementation}
\begin{lstlisting}[language=Java, caption = BaseUserMongoDBDAO.java]
AggregateIterable<Document> aggregateResult = collectionMovie.aggregate(
                Arrays.asList(
                        Aggregates.match(eq("review.critic_name",username)),
                        Aggregates.unwind("$genres"),
                        Aggregates.group("$genres",
                                sum("count",1)),
                        Aggregates.sort(Sorts.descending("count")),
                        Aggregates.limit(Constants.HALL_OF_FAME_ELEMENT_NUMBERS)
                )
        );
\end{lstlisting}
\subsection{Return the number of user divided by an age bucket}\label{subsec:userPopulationBucket}
\subsubsection{Mongo shell}
\lstinputlisting[language=JavaScript, caption = userPopulation.js]{./../code/userPopulationBucket.js}

\subsubsection{Java implementation}
\begin{lstlisting}[language=Java, caption = AdminMongoDBDAO.java]
BucketOptions opt = new BucketOptions();
        ArrayList<Integer> buck=new ArrayList<>();
        opt.output(new BsonField("population",new Document("$sum",1)));
        int bucketYear=1970;
        buck.add(bucketYear);
        while(bucketYear<=2010){
            bucketYear=(bucketYear+offset);
            buck.add(bucketYear);
        }
        AggregateIterable<Document> aggregateResult = collectionUser.aggregate(
                Arrays.asList(
                        Aggregates.match(exists("date_of_birth")),
                        Aggregates.bucket(new Document("$year","$date_of_birth"),buck,opt)
                )
        );
\end{lstlisting}

\section{Sharding considerations}
We consider the possibility of sharding the movie collection, with the benefit of much less space occupation, using id as a possible sharding key. However we realized that we search movies not only by id but also with their primary titles, their years, etc. With these type of queries we end up in a query flooding scenario, where every replica must be consulted in order to find the appropriate document.
 %\end{document}
