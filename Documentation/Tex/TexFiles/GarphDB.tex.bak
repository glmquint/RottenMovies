\include{./preamble}
\begin{document}
\chapter{Graph database}
\justifying
The DBSM chosen for the graph database is Neo4j, it was use to manege the social part of the site and also to keep track of the reviews made for the feed and suggestion functionality.
%ADD SUGGESTION FUNTIONALITY IN DESIGN CHAPTER

The entities used in the database are:
\begin{itemize}
	\item User
	\item TopCritic
	\item Movie
\end{itemize}
The nodes themselves do not store a lot of data, we decided to keep the bare minimum by having the following attributes:
\begin{itemize}
	\item for the User and TopCritic:
	\begin{itemize}
		\item id
		\item name
	\end{itemize}
	\item for Movie:
	\begin{itemize}
		\item id
		\item title
	\end{itemize}
\end{itemize}
The relationship present are:
\begin{itemize}
	\item User -[:FOLLOWS]-> TopCritic
	\item User -[:REVIEWED]-> Movie
	\item TopCritic -[:REVIEWED]-> Movie
\end{itemize}
In particular the \emph{REVIEWED} relationship contains the following information:
\begin{itemize}
	\item content
	\item date
	\item freshness
\end{itemize}

Below is present a snapshot of the graph database taken from Neo4j.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.45]{/images/PNG/graph.png}
\caption{graph DB}
\label{fig:graphDB}
\end{center}
\end{figure}

As previously stated in the Feasibility study section \ref{sec:result}, the graph database design was heavily influenced by the document one, it was in fact generated by python script \cref{subsec:createGraphDB} that starts from the movie collection and, after generating the nodes for the \emph{Movie} entity, does the same for the user by dividing them between normal user and top critic. It then generates the \emph{REVIEWED} relationship based upon the data stored in the document database and finally it generates the \emph{FOLLOWS} relationship randomly

\section{Index}
The \emph{id} attributes is common to all nodes and it stores a string which is also used as id by the document database in the \emph{\textunderscore id} field, this choice was made so that we could have a way to identify the same object across the different databases with only one string from the application. Due to the OOP language used to build the latter the data in class containing the id of the object  

\lstinputlisting[language=json]{./../code/graphIndex.json}
\end{document}